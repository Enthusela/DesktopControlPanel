WordPress draft notes

//void softTakeover {
//  // Purpose: allow for two controls to be captured on one pot by switching between the two.
//  // If the pot position does not correspond to the value being controlled, the pot will not take control
//  // until the user physically moves it into the correct position. Moving the pot then updates the value.
//  // This transition from non-functioning when out of position to functioning when in position is known as soft takeover.
//  // When activated, one of two LEDs will turn on to indicate to the user which direction the pot must be turned.
//  // The LED brightness is inversely proportional to the distance between the pot's current and required positions.
//
//}

On knobs without ring-lights assigned
    soft takeover can still be done without a ring-light;
    the user just has to twiddle the knob until the desired 
    variable starts changing. Not a great UI, and I would
    never implement it like that, but I like that I'm handling
    the ringlight = 0 edge-case

On a separate LED-Indicator class (which became the RingLight class)
    void setIndicators (on, optional: pos, target)
        set lighting orientation and intensity based on pot direction and distance from the takeover point, respectively.
        //
        Unlike the switch, I think the LEDs should be associated with the pot
        I don't see any reason why they should be showing the values from other pots
        If a case for external control comes up (which it probably will, now I think about it), a setter function can be added
        ...hmmmm, what about global changes like, I dunno, power-on sweeps or stuff
        ...lets write it assuming they're internal, and if we need to define an IndicatorLED class then we can
        I ended up going ahead with a separate class, see justification below

On the RingLight class
    The idea here was to allow for a hardware-agnostic indicator light function
    A given ControlKnob instance can be assigned a RingLight object and pass it potPos and potTarget when it needs to generate soft-takeover lighting effects.
    How exactly this is generated and how it looks depends on info the ControlKnob doesn't need to know: the number, layout, and type of the LEDs in the RingLight.
    That being said, I figure that a position and a target should be enough external info for the RingLight to calculate just about any lighting indication pattern
    that I can dream up; it knows where the pot is, and it knows where it's going.
    What might it not know, though?
    Well, the position of the potPos zero-point relative to LED[0], for a start.
    That being said, given that this is ultimately a one-off hardware project I should be able to establish a standard RingLight design spec, 
    reflected in the class definition, that establishes a standard reference frame: e.g., potPos 0 is 7 o'clock, 1023 is 5 o'clock.
    Could I not just pass out the zero-position to the function?
    softTakeoverLighting(bool dir, int potPos, int potTarget, int zeroPos)
        zeroPos is a value in degrees CCW from 0 (right-hand horizontal on the X-Y plane) where potPos is measured from
        dir is the direction potPos is measured from zeroPos: true = CW, false = CCW
        ...I like it
        zeroPos and dir can be defined as constant values for the ControlKnob instance, too

On ControlKnobs with no defined functions
    My original thoughts were:
        if num fnPtr args < 1
            throw error: "need at least one function defined"
            mode numbers without associated functions will do nothing
            This enables hardware flexibility as we may want to use
            switches with more positons than we have functions,
            and I for one don't want the code chucking a wobbly about it.
    But now I'm thinking
        if num fnPtr args < 1
            initialise modeFnPtr[] with nulls
            modify getModeVal to return the raw controlKnob value (i.e. 0-1023) if any mode is called
    But actually straight away I'm thinking
        No, my original thoughts are right
        if num fnPtr args < numMode
            throw error: "all modes need assigned functions"
        But also add in a public function getPotPos()
        Why?
        Because allowing knobs to have functionless modes is stupid.
        Defined modes doing nothing is, I think, a type of silent failure.
        If the knob's associated switch has physical positions that we're not using, 
        then the modeNum value should be defined accordingly
            Unused positions do not have modes defined for them
            Any modes that *are* defined must have associated functions
            If you still want to define a "useless" mode that just returns the raw pot value,
            that should still be defined as a mode, but the corresponding function can be
            set to getPotPos()
        After all that mode-defining, any object that wants the raw pot value can still call
        getPotPos directly.
        Nice. It's comprehensive, I like it.

On seperate Switch class:
    I might want a separate switch class to handle switch control and send changes to pots.
    This would mean switches could be easily reassigned to other pots or be used to control multiple pots
    Defining the functions in the switch, rather than the knob:
        The idea here was to define the functions that a switch is designed to select between on the switch itself,
        and then have any assigned knobs pull those functions from the switch when being initialised.
        To be honest, I'm not sure if this is a great idea, but I'm trying to find a way of ensuring a knob instance
        isn't constructed without an equal number of modes and mode functions. The number has to be defined somewhere,
        but I'm wrestling with c++ not wanting me to create arrays with lengths that are not defined at runtime.
        Update: this should be solvable with lists
        Back to it: it makes more sense to me (currently) to have the modes associated with the switch, rather than the knob.
        Switch-defined Fns: Switch has physical positions corresponding to functions (which will be on the faceplate), 
            and when moved to that position/function, all assigned knobs activate that function.
        Knob defined Fns: Switch has physial positions corresponding to arbitrary function numbers, and when moved to 
            that position, all assigned knobs activate their own functions assigned to that number, which may differ.
        So, knob-defined Fns act almost like a macro knob in Ableton, which could be useful, but isn't really what 
        I want.
        Or is it?
        Option 1: Fixed switch functions. Switches point to single function on the faceplate: all knobs enable that function
            e.g. color temp mode: knobs for different areas all switch to color temp mode
        Option 2: Macro switch functions. Switches point to mode on the nameplate: different knobs enable different
            e.g. room control: knob 1 goes to color, knob 2 goes to brightness
        Tbh I think I'm getting ahead of myself, all I wanted to do was get a soft take-over function working.
        Lets set it up with per-switch function definitions for now.
        I need to get a better spec for what functionality I actually want going before I make a decision.
        That being said, the more thought I put into flexibility now, the less I'll (probably) have to put in later on 
        when implementing whatever I decide that I want.
        Decisions, decisions...